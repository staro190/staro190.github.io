# 삽입 정렬(insertion sorting)

삽입 정렬은 정렬된 리스트에 새로운 키(데이터)를 삽입하는 방식으로 진행됩니다.
<br>
배열의 모든 요소를 앞에서부터 차례대로 비교하여 들어가야할 위치를 찾아 삽입합니다.


<br>

## 파이썬 코드

```python
def insertion_sort(arr):
    """리스트를 삽입 정렬 알고리즘으로 정렬합니다."""
    # 리스트의 두 번째 요소(인덱스 1)부터 시작
    for i in range(1, len(arr)):
        key = arr[i]  # 삽입할 요소
        j = i - 1
        
        # key보다 큰 요소를 오른쪽으로 한 칸씩 이동시켜
        # 삽입될 공간을 마련합니다.
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        
        # 찾은 위치에 key를 삽입
        arr[j + 1] = key
        
    return arr
```

## 정렬 동작

<div id="solarsys-sort-visualization"></div>

## 시간 복잡도 함수

- **점근적 표기법(Asympotic Notation)**     
입력 크기 n이 무한으로 갈때 알고리즘의 우열을 가리기 위해 필수적인 부분(높은 차수)에 집중하여 증가 속도를 비교하는 방법입니다.

1. **O-notation** : 최악의 경우 사용(가장 시간이 오래 걸리는 경우)
     - n0 보다 큰 n에 대해 0 ≤ f(n) ≤ cg(n) 을 만족하는 양의 상수 c가 존재합니다.
     - 여기서 f(n)은 추정해야하는 실제 시간복잡도이며 g(n)이 점근적 상한이 됩니다.

2. **Ω-notation** : 최소한의 경우 사용(가장 시간이 적게 걸리는 경우)
     - n0 보다 큰 n에 대해 0 ≤ cg(n) ≤ f(n) 을 만족하는 양의 상수 c가 존재합니다.
     - 여기서 f(n)은 추정해야하는 실제 시간복잡도이며 g(n)이 점근적 하한이 됩니다.
     
3. **Θ-notation** : 좁은 범위로 추정할 경우 사용(실제 시간복잡도와 근접)
     - n0 보다 큰 n에 대해 c1g(n) ≤ f(n) ≤ c2g(n) 을 만족하는 양의 상수 c1과 c2가 존재합니다.
     - 여기서 f(n)은 추정해야하는 실제 시간복잡도이며 g(n)이 점근적 상하한이 됩니다.
     
4. **o-notation** : 최악의 경우 사용(O 보다 엄격함)
     - n0 보다 큰 n에 대해 0 < f(n) < cg(n) 을 만족하는 양의 상수 c가 존재합니다.

5. **ω-notation** : 최소한의 경우 사용(Ω 보다 엄격함)
     - n0 보다 큰 n에 대해 0 < cg(n) < f(n) 을 만족하는 양의 상수 c가 존재합니다.
     

- **시간복잡도 우열:** log(n) ≤ n ≤ nlog(n) ≤ n^2 ≤ 2^n