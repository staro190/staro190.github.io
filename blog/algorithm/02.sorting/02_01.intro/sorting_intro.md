# 정렬(Sorting)

정렬은 데이터나 항목을 특정 기준에 따라 오름차순 또는 내림차순으로 나열하는 문제입니다.
<br>
여기서 **입력**은 데이터나 항목이고 **출력**은 특정 기준에 따라 오름차순 또는 내림차순으로 나열된 데이터나 항목입니다.


<br>

## 분할 정복(Devide-and-Conquer)

데이터를 분할하고 분할된 데이터에 대해 정복(정렬)하는 방식을 의미합니다.
<br>
분할은 일반적으로 재귀(Recursive) 호출을 사용하며 이로 인해 실행 시간은 점화식(Recurrence)으로 기술합니다.
<br>
분할 정복 알고리즘의 시간 복잡도는 아래 3가지 방법을 통해 구할 수 있습니다.
<br>

1. **대체 방법(Substitution Method)** : 해를 추측하고 이를 귀납법으로 증명. 
     - 시간 복잡도를 추측합니다.
     - 추측한 시간 복잡도가 맞는지 수학적 귀납법을 통해 검증합니다.

2. **재귀 트리(Recursion-tree)** : 점화식을 트리 형태로 변환하여 구함
     - 해를 추측할 때 주로 사용합니다.
     - 불균형 트리의 경우 깊은 쪽의 Level을 구하고 이를 기준으로 사용합니다.

3. **마스터 방법(Master Method)** : 일반화된 형태의 점화식을 사용함
     - 형태의 점화식을 사용하여 시간 복잡도를 구합니다.
     - $T(n) = aT(\frac{n}{b}) + f(n)$ 

<br>

위 방법들 사용 시 편의를 위해 아래의 추가 가정을 사용합니다.
<br>

1. **정수 인수 가정**         
     점화식 풀이 시 인수는 항상 정수라는 가정입니다.
     $(T(⌈n/2⌉)+T(⌊n/2⌋) = 2T(n/2))$
     
2. **경계 조건 생략**          
     $n$ 이 작을 경우 시간 복잡도는 상수[O(1)]이므로 조건을 생략합니다.