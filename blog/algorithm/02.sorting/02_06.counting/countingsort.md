# 계수 정렬(Counting sorting)

데이터의 범위를 유한하게 제한하여 비교를 거의 쓰지 않는 방식으로 선형 실행 횟수를 달성합니다.
<br>
0 ~ k 범위의 정수인 경우 각 값의 빈도를 세고 누적합으로 각 값의 최종 위치를 계산하여 배치합니다.
<br>
<br>

## 파이썬 코드

```python
def counting_sort(arr):
  """
  누적 합계를 사용하여 안정성을 보장하는 계수 정렬입니다. (수도코드 수준)
  """

  # 1. 카운트(count) 배열 및 결과(output) 배열 생성
  max_val = max(arr) # k
  count_arr = [0] * (max_val + 1)
  output_arr = [0] * len(arr)
  
  # 2. 카운트 배열에 각 원소의 빈도수 기록
  #    (이전 방식과 동일)
  for num in arr:
    count_arr[num] += 1

  # 3. 카운트 배열을 '누적 합계' 배열로 변환 ⭐️
  #    - 각 인덱스의 값은 '해당 숫자 이하의 숫자들이 총 몇 개 있는지'를 의미하게 됨
  #    - 이는 각 숫자가 정렬될 때 들어갈 '마지막 위치' 정보가 됨
  for i in range(1, len(count_arr)):
    count_arr[i] += count_arr[i-1]

  # 4. 입력 배열을 역순으로 순회하며 결과 배열에 정렬된 값 채우기 ⭐️
  #    - 역순으로 순회해야 같은 값일 경우 원본 배열의 뒤에 있던 요소가
  #      결과 배열에도 뒤쪽에 위치하게 되어 '안정성'이 보장됨
  for num in reversed(arr):
    # 누적 합계 배열에서 현재 숫자의 위치를 찾음
    # (배열 인덱스는 0부터 시작하므로 1을 빼줌)
    position = count_arr[num] - 1
    
    # 결과 배열의 해당 위치에 현재 숫자를 삽입
    output_arr[position] = num
    
    # 해당 숫자의 누적 카운트를 1 감소시킴
    # (다음에 같은 숫자가 나올 경우 바로 앞 위치에 배치하기 위함)
    count_arr[num] -= 1
      
  return output_arr

```

## 정렬 동작

![시각화 준비중](ready_to_visual.png)
## 시간 복잡도

- **Θ-notation** = $Θ(n+k)$          
알고리즘을 분석해보면 데이터 계수, 누적합 계산, 역순 추출로 나누어 분석할 수 있습니다.          
   - 데이터 계수 부분은 데이터를 순회하므로 $Θ(n)$입니다.
   - 누적합 계산은 데이터 개수가 저장된 배열을 순회하므로 $Θ(k)$입니다.
   - 역순 추출은 원본 데이터를 역순으로 순회하므로 $Θ(n)$입니다.
   - 최종적으로 이 셋을 모두 더해야 하므로 아래와 같습니다.          
$Θ(2n + k) = Θ(n + k)$
   
- **선형 시간 복잡도**          
k가 n보다 작거나 비슷한 경우 선형 시간 복잡도에 가까워집니다.

## 공간 복잡도 및 특징

- **공간 복잡도**          
개수를 저장할 배열(C)과 출력 데이터가 저장될 배열(B)가 필요하므로 $Θ(n+k)$ 입니다.          
Stable 속성을 위해 출력 데이터 배열을 따로 지정하여 정렬합니다.

- **Not In-place**          
출력 데이터 공간이 별도로 필요하므로 In-place 하지 않습니다.          

- **Stable**          
역순으로 해당 순서에 맞는 위치에 같은 데이터를 이동하므로 Stable 합니다.