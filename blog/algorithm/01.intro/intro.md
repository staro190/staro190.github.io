# 알고리즘(Algorithm)

알고리즘은 **문제**를 풀기위해 잘 정의된 절차를 의미합니다.
<br>
여기서 **문제**는 잘 기술된 입력과 출력이며 입력 시 나와야 하는 출력을 의미합니다.


<br>

## 알고리즘의 비교

여러 알고리즘을 비교하기 위해 우리는 알고리즘의 성능을 측정할 필요가 있습니다.
<br>
이때 크게 2가지 성능 지표를 사용하며 아래와 같습니다.
<br>
1. **실행 시간** : 알고리즘이 실행될 때 필요한 시간입니다. 
     - 하드웨어에 따라 같은 알고리즘의 실행 시간이 서로 다를 수 있습니다.
     - 위 문제를 해결하기 위해 실제 실행시간이 아닌 입력 크기를 n으로 두는 논리적 실행 시간을 고려합니다.
     - 논리적 실행 시간인 시간복잡도 T(n) 을 정의 합니다.

2. **공간 소비** : 필요한 메모리 공간입니다. 
     - 하드웨어에 크게 좌우되지 않습니다.

## 시간 복잡도 함수

- **점근적 표기법(Asympotic Notation)**     
입력 크기 n이 무한으로 갈때 알고리즘의 우열을 가리기 위해 필수적인 부분(높은 차수)에 집중하여 증가 속도를 비교하는 방법입니다.

1. **O-notation** : 최악의 경우 사용(가장 시간이 오래 걸리는 경우)
     - n0 보다 큰 n에 대해 0 ≤ f(n) ≤ cg(n) 을 만족하는 양의 상수 c가 존재합니다.
     - 여기서 f(n)은 추정해야하는 실제 시간복잡도이며 g(n)이 점근적 상한이 됩니다.

2. **Ω-notation** : 최소한의 경우 사용(가장 시간이 적게 걸리는 경우)
     - n0 보다 큰 n에 대해 0 ≤ cg(n) ≤ f(n) 을 만족하는 양의 상수 c가 존재합니다.
     - 여기서 f(n)은 추정해야하는 실제 시간복잡도이며 g(n)이 점근적 하한이 됩니다.
     
3. **Θ-notation** : 좁은 범위로 추정할 경우 사용(실제 시간복잡도와 근접)
     - n0 보다 큰 n에 대해 c1g(n) ≤ f(n) ≤ c2g(n) 을 만족하는 양의 상수 c1과 c2가 존재합니다.
     - 여기서 f(n)은 추정해야하는 실제 시간복잡도이며 g(n)이 점근적 상하한이 됩니다.
     
4. **o-notation** : 최악의 경우 사용(O 보다 엄격함)
     - n0 보다 큰 n에 대해 0 < f(n) < cg(n) 을 만족하는 양의 상수 c가 존재합니다.

5. **ω-notation** : 최소한의 경우 사용(Ω 보다 엄격함)
     - n0 보다 큰 n에 대해 0 < cg(n) < f(n) 을 만족하는 양의 상수 c가 존재합니다.
     

- **시간복잡도 우열:** log(n) ≤ n ≤ nlog(n) ≤ n^2 ≤ 2^n