# 막대 자르기(Rod Cutting)

2개의 라인이 있고 $n$개의 스테이션을 거쳐야 할 경우 가장 빠르게 완료될 수 있는 경로를 찾는 문제입니다.
<br>
DP를 사용하여 점화식 정의 및 메모를 통해 문제를 해결합니다.


<br>

## 파이썬 코드
```python
def rod_cutting_bottom_up(prices, n):
  """
  DP(상향식)를 이용한 막대 자르기 문제입니다. (수도코드 수준)
  
  prices: [길이 1의 가격, 길이 2의 가격, ...] 리스트
  n: 막대의 총 길이
  """
  
  # 1. DP 테이블 초기화
  # dp[i]는 "길이가 i인 막대의 최대 판매 수익"을 저장합니다.
  # 길이는 0부터 n까지 있으므로, 크기는 n+1입니다.
  dp = [0] * (n + 1)

  # 2. DP 테이블 채우기 (길이 1부터 n까지)
  # i: 현재 계산하려는 막대의 길이
  for i in range(1, n + 1):
    max_revenue = -1 # 현재 길이 i에서의 최대 수익을 찾기 위한 변수
    
    # 3. 점화식 계산
    #    - 막대 i를 어떻게 자를지 모든 경우를 탐색합니다.
    #    - 'j'는 첫 번째로 자르는 조각의 길이 (1부터 i까지)
    for j in range(1, i + 1):
      # 옵션: 
      # 1. (길이 j의 가격) + (길이 i-j의 최대 수익)
      #    prices[j-1]은 길이 j의 가격 (인덱스는 0부터 시작하므로)
      #    dp[i-j]는 이전에 계산해둔 길이 i-j의 최적해
      current_revenue = prices[j-1] + dp[i-j]
      max_revenue = max(max_revenue, current_revenue)
      
    # 길이 i에 대한 최적해(최대 수익)를 DP 테이블에 저장
    dp[i] = max_revenue

  # 4. 최종 결과 반환
  # 테이블의 마지막 값, 즉 길이 n일 때의 최대 수익을 반환
  return dp[n]
```

## 알고리즘 동작

<div class="slideshow-container" data-duration="3000"></div>

## 점화식

- **기저 조건**          
막대 길이가 0 일때 최대 가격은 0으로 설정
$$r_0 = 0$$

- **점화식**          
길이가 $i$ 일 때 최대 가격인 $r_i$은 아래 점화식을 따라 계산되며,          
1부터 $n$ 까지, $i$ 길이의 막대 가격과 분할된 최대 가격 $r_{n_i}$을 합한 것 중 가장 큰 값을 선택합니다.
$$r_n = \max_{1 \le i \le n} (p_i + r_{n-i})$$

## 시간 복잡도

- **O-notation** = $O(n^2)$          
$n$ 길이의 막대 최대 가격인 $r_n$을 구하기 위해서는 $r_1, r_2 \dots r_{n-1}$을 모두 계산해 두여야 합니다.          
이때 각 최대 가격은 점화식에 따라 최대 $n-1$ 만큼 비교 연산을 하게 됩니다.          
따라서 $n$개의 $r$을 구하기 위해 내부에서 최대 $n-1$번 반복되므로 $O(n^2)$입니다.

## 공간 복잡도 및 특징

- **공간 복잡도**          
메모 방법(Memoization)을 사용해야 하므로 저장할 공간이 필요하며,          
알고리즘 동작에 나오는 표 처럼 $r$ 테이블($n+1$)이 필수로 필요합니다.          
또한 어디서 나눠야 하는지 저장해두려면 $s$ 배열이 같은 크기로 필요하므로          
$O(n+1) + O(n+1) = O(n)$