# 막대 자르기(Rod Cutting)

2개의 라인이 있고 $n$개의 스테이션을 거쳐야 할 경우 가장 빠르게 완료될 수 있는 경로를 찾는 문제입니다.
<br>
DP를 사용하여 점화식 정의 및 메모를 통해 문제를 해결합니다.


<br>

## 파이썬 코드
```python
def rod_cutting_bottom_up(prices, n):
  """
  DP(상향식)를 이용한 막대 자르기 문제입니다. (수도코드 수준)
  
  prices: [길이 1의 가격, 길이 2의 가격, ...] 리스트
  n: 막대의 총 길이
  """
  
  # 1. DP 테이블 초기화
  # dp[i]는 "길이가 i인 막대의 최대 판매 수익"을 저장합니다.
  # 길이는 0부터 n까지 있으므로, 크기는 n+1입니다.
  dp = [0] * (n + 1)

  # 2. DP 테이블 채우기 (길이 1부터 n까지)
  # i: 현재 계산하려는 막대의 길이
  for i in range(1, n + 1):
    max_revenue = -1 # 현재 길이 i에서의 최대 수익을 찾기 위한 변수
    
    # 3. 점화식 계산
    #    - 막대 i를 어떻게 자를지 모든 경우를 탐색합니다.
    #    - 'j'는 첫 번째로 자르는 조각의 길이 (1부터 i까지)
    for j in range(1, i + 1):
      # 옵션: 
      # 1. (길이 j의 가격) + (길이 i-j의 최대 수익)
      #    prices[j-1]은 길이 j의 가격 (인덱스는 0부터 시작하므로)
      #    dp[i-j]는 이전에 계산해둔 길이 i-j의 최적해
      current_revenue = prices[j-1] + dp[i-j]
      max_revenue = max(max_revenue, current_revenue)
      
    # 길이 i에 대한 최적해(최대 수익)를 DP 테이블에 저장
    dp[i] = max_revenue

  # 4. 최종 결과 반환
  # 테이블의 마지막 값, 즉 길이 n일 때의 최대 수익을 반환
  return dp[n]
```

## 알고리즘 동작

<div class="slideshow-container" data-duration="3000"></div>

## 점화식

- **기저 조건**          
$f_k[i]$는 $k$번 조립라인 $i$번 스테이션의 최소 시간,          
$e_k$는 $k$번 조립라인 진입 시간,          
$a_{k,i}$는 $k$번 조립라인 $i$번 스테이션의 작업 시간
$$f_1[1] = e_1 + a_{1,1}$$
$$f_2[1] = e_2 + a_{2,1}$$

- **각 스테이션(점화식)**          
$f_k[i]$는 $k$번 조립라인 $i$번 스테이션의 최소 시간,          
$a_{k,i}$는 $k$번 조립라인 $i$번 스테이션의 작업 시간,          
$t_{k,i}$는 $k$번 조립라인의 $i-1$번 스테이션에서 출발하여 반대 조립라인의 $i$번 스테이션으로 변환되는 시간
$$f_1[i] = \min(f_1[i-1] + a_{1,i}, \quad f_2[i-1] + t_{2,i-1} + a_{1,i})$$
$$f_2[i] = \min(f_2[i-1] + a_{2,i}, \quad f_1[i-1] + t_{1,i-1} + a_{2,i})$$

- **최종 진단**          
$x_k$는 $k$번 조립라인 탈출 시간,          
$$f_{\text{total}} = \min(f_1[n] + x_1, \quad f_2[n] + x_2)$$

## 시간 복잡도

- **O-notation** = $O(n)$          
알고리즘의 동작을 따라가며 $n \times 2$ 배열(전체 스테이션 수)에 메모를 하게 됩니다.          
이때 이 배열을 모두 채우기 위해서 각 스테이션에서 2개 값을 연산 및 비교하므로 $4n$ 번 연산을 수행합니다.

## 공간 복잡도 및 특징

- **공간 복잡도**          
기본적으로 각 스테이션의 최소 시간을 저장하기 위한 배열이 필요하므로 $n$ 입니다.          
경로가 필요한 경우 이를 쉽게 하기 위해 $n-2$ 배열이 추가로 필요합니다.          
$O(n) + O(n-2) = O(n)$