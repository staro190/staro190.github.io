# 막대 자르기(Rod Cutting)

2개의 라인이 있고 $n$개의 스테이션을 거쳐야 할 경우 가장 빠르게 완료될 수 있는 경로를 찾는 문제입니다.
<br>
DP를 사용하여 점화식 정의 및 메모를 통해 문제를 해결합니다.


<br>

## 파이썬 코드
```python
def assembly_line_scheduling(a1, a2, t1, t2, e1, e2, x1, x2):
  """
  어셈블리 라인 스케줄링 문제를 해결하는 DP 알고리즘입니다. (수도코드 수준)
  
  a1, a2: 각 라인의 스테이션별 작업 시간 리스트
  t1, t2: 다른 라인으로 이동하는 데 걸리는 시간 리스트
  e1, e2: 각 라인의 진입 시간
  x1, x2: 각 라인의 탈출 시간
  """
  n = len(a1) # 스테이션의 개수

  # 1. DP 테이블 초기화
  # f1[i] = 1번 라인의 i번째 스테이션까지 가는 최단 시간
  # f2[i] = 2번 라인의 i번째 스테이션까지 가는 최단 시간
  f1 = [0] * n
  f2 = [0] * n

  # 2. 기본값(첫 번째 스테이션) 계산
  # 진입 시간 + 첫 스테이션 작업 시간
  f1[0] = e1 + a1[0]
  f2[0] = e2 + a2[0]

  # 3. 점화식에 따라 DP 테이블 채우기 (두 번째 스테이션부터 끝까지)
  for i in range(1, n):
    # --- 1번 라인의 i번째 스테이션으로 오는 경우 ---
    # 옵션 1: 1번 라인에 머무는 경우 (f1[i-1]에서 바로 오는 길)
    stay_on_line1 = f1[i-1] + a1[i]
    # 옵션 2: 2번 라인에서 넘어오는 경우 (f2[i-1]에서 건너오는 길)
    switch_from_line2 = f2[i-1] + t2[i-1] + a1[i]
    f1[i] = min(stay_on_line1, switch_from_line2)

    # --- 2번 라인의 i번째 스테이션으로 오는 경우 ---
    # 옵션 1: 2번 라인에 머무는 경우 (f2[i-1]에서 바로 오는 길)
    stay_on_line2 = f2[i-1] + a2[i]
    # 옵션 2: 1번 라인에서 넘어오는 경우 (f1[i-1]에서 건너오는 길)
    switch_from_line1 = f1[i-1] + t1[i-1] + a2[i]
    f2[i] = min(stay_on_line2, switch_from_line1)

  # 4. 최종 시간 계산 (마지막 스테이션 + 탈출 시간)
  # 1번 라인에서 끝내는 경우와 2번 라인에서 끝내는 경우 중 더 빠른 시간 선택
  final_time1 = f1[n-1] + x1
  final_time2 = f2[n-1] + x2
  
  return min(final_time1, final_time2)

# --- 예시 사용법 ---
# 스테이션은 4개라고 가정
# 라인 1의 스테이션별 작업 시간
a1 = [4, 5, 3, 2]
# 라인 2의 스테이션별 작업 시간
a2 = [2, 10, 1, 4]
# 라인 1 -> 2 이동 시간
t1 = [7, 4, 5] # 스테이션 0->1, 1->2, 2->3 이동
# 라인 2 -> 1 이동 시간
t2 = [9, 2, 8]
# 진입/탈출 시간
e1, e2 = 10, 12
x1, x2 = 18, 7

```

## 알고리즘 동작

![시각화 준비중](ready_to_visual.png)

## 점화식

- **기저 조건**          
$f_k[i]$는 $k$번 조립라인 $i$번 스테이션의 최소 시간,          
$e_k$는 $k$번 조립라인 진입 시간,          
$a_{k,i}$는 $k$번 조립라인 $i$번 스테이션의 작업 시간
$$f_1[1] = e_1 + a_{1,1}$$
$$f_2[1] = e_2 + a_{2,1}$$

- **각 스테이션(점화식)**          
$f_k[i]$는 $k$번 조립라인 $i$번 스테이션의 최소 시간,          
$a_{k,i}$는 $k$번 조립라인 $i$번 스테이션의 작업 시간,          
$t_{k,i}$는 $k$번 조립라인의 $i-1$번 스테이션에서 출발하여 반대 조립라인의 $i$번 스테이션으로 변환되는 시간
$$f_1[i] = \min(f_1[i-1] + a_{1,i}, \quad f_2[i-1] + t_{2,i-1} + a_{1,i})$$
$$f_2[i] = \min(f_2[i-1] + a_{2,i}, \quad f_1[i-1] + t_{1,i-1} + a_{2,i})$$

- **최종 진단**          
$x_k$는 $k$번 조립라인 탈출 시간,          
$$f_{\text{total}} = \min(f_1[n] + x_1, \quad f_2[n] + x_2)$$

## 시간 복잡도

- **O-notation** = $O(n)$          
알고리즘의 동작을 따라가며 $n \times 2$ 배열(전체 스테이션 수)에 메모를 하게 됩니다.          
이때 이 배열을 모두 채우기 위해서 각 스테이션에서 2개 값을 연산 및 비교하므로 $4n$ 번 연산을 수행합니다.

## 공간 복잡도 및 특징

- **공간 복잡도**          
기본적으로 각 스테이션의 최소 시간을 저장하기 위한 배열이 필요하므로 $n$ 입니다.          
경로가 필요한 경우 이를 쉽게 하기 위해 $n-2$ 배열이 추가로 필요합니다.          
$O(n) + O(n-2) = O(n)$