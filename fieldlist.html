<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Orbit of Learning - Destination</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* 스크롤바 제거 */
            background: #000;
            color: #fff;
            font-family: 'Orbitron', sans-serif; /* SF 느낌의 폰트 적용 */
        }

        /* 배경 파티클용 캔버스 */
        #bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* 행성 선택 UI용 캔버스 */
        #planetSelector {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        
        /* UI 전체를 감싸는 컨테이너 */
        .hud-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw; /* 화면 너비의 90% */
            max-width: 800px; /* 최대 너비 제한 */
            height: auto;
            text-align: center;
            z-index: 20;
            pointer-events: none; /* 컨테이너는 클릭되지 않도록 설정 */
        }
        
        .hud-container h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #00d4ff;
            text-shadow: 0 0 10px #00d4ff;
        }

        /* 선택된 행성 이름을 표시할 영역 */
        #selected-planet-name {
            font-size: 2em;
            height: 60px; /* 이름이 바뀌어도 레이아웃이 밀리지 않도록 높이 고정 */
            line-height: 60px;
            color: #fff;
            text-shadow: 0 0 15px #fff;
            transition: opacity 0.3s ease;
        }

        /* 워프 버튼 */
        #warp-button {
            pointer-events: all; /* 버튼은 클릭 가능하도록 설정 */
            margin-top: 300px; /* 캔버스 아래에 위치하도록 조정 */
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            color: #000;
            background: #00d4ff;
            border: 2px solid #00d4ff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px #00d4ff;
        }

        #warp-button:hover {
            background: #fff;
            color: #00d4ff;
            box-shadow: 0 0 30px #fff;
        }

    </style>
</head>
<body>
    <canvas id="bg"></canvas>

    <canvas id="planetSelector"></canvas>

    <div class="hud-container">
        <h1>SELECT DESTINATION</h1>
        <div id="selected-planet-name"></div>
        <button id="warp-button">WARP</button>
    </div>

    <script>
      const bgCanvas = document.getElementById('bg');
      const bgCtx = bgCanvas.getContext('2d');
      let particles = [];

      function initCanvas(){
        bgCanvas.width = window.innerWidth;
        bgCanvas.height = window.innerHeight;
        initParticles();
      }

      function initParticles(){
        particles = [];
        const particleCount = 100; // 별 개수 증가
        for(let i=0; i<particleCount; i++){
          particles.push({
            x: Math.random() * bgCanvas.width,
            y: Math.random() * bgCanvas.height,
            vx: (Math.random() - 0.5) * 0.3,
            vy: (Math.random() - 0.5) * 0.3,
            size: Math.random() * 1.5 + 0.5
          });
        }
      }

      function drawParticles(){
        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
        bgCtx.fillStyle = "#fff"; // 별 색상
        particles.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;

          if(p.x < 0) p.x = bgCanvas.width;
          if(p.x > bgCanvas.width) p.x = 0;
          if(p.y < 0) p.y = bgCanvas.height;
          if(p.y > bgCanvas.height) p.y = 0;

          bgCtx.beginPath();
          bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          bgCtx.fill();
        });
        requestAnimationFrame(drawParticles);
      }

      window.addEventListener('resize', initCanvas);
      initCanvas();
      drawParticles();
    </script>
    
    <script>
        const canvas = document.getElementById('planetSelector');
        const ctx = canvas.getContext('2d');
        const planetNameEl = document.getElementById('selected-planet-name');
        const warpButton = document.getElementById('warp-button');

        // ===================================================
        // ✅ 행성 데이터를 이곳에서 수정하세요
        // ===================================================
        const planets = [
            { name: 'Computer Science', imgSrc: './img/planet_cs.png', link: 'cs_main.html', color: '#00d4ff' },
            { name: 'Artificial Intelligence', imgSrc: './img/planet_ai.png', link: 'ai_main.html', color: '#ff4dd2' },
            { name: 'Cyber Security', imgSrc: './img/planet_sec.png', link: 'sec_main.html', color: '#ffdf70' },
            { name: 'Algorithm', imgSrc: './img/planet_algo.png', link: 'algo_main.html', color: '#4dff88' },
            { name: 'Network', imgSrc: './img/planet_net.png', link: 'net_main.html', color: '#ff8c4d' }
            // 여기에 계속 추가...
        ];
        // ===================================================

        // 이미지 로딩
        planets.forEach(p => {
            const img = new Image();
            img.src = p.imgSrc;
            p.image = img;
        });

        let angle = 0;
        let targetAngle = 0;
        let dragStartX = null;
        let startAngle = 0;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = 500;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 부드러운 회전을 위한 각도 업데이트 (관성)
            angle += (targetAngle - angle) * 0.1;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width / 3, 250); // 회전 반지름

            // 3D 효과를 위해 z좌표(깊이)를 계산하여 정렬
            planets.forEach((planet, i) => {
                const planetAngle = angle + (i * Math.PI * 2 / planets.length);
                planet.z = Math.cos(planetAngle);
            });
            planets.sort((a, b) => a.z - b.z);

            let frontPlanet = null; // 가장 앞에 있는 행성

            // 행성 그리기
            planets.forEach((planet) => {
                const planetAngle = angle + (planets.findIndex(p => p.name === planet.name) * Math.PI * 2 / planets.length);
                const x = centerX + radius * Math.sin(planetAngle);
                const z = Math.cos(planetAngle); // -1(뒤) to 1(앞)

                // 원근감 적용
                const scale = (z + 1.5) / 2.5; // 0.2 ~ 1
                const y = centerY + z * 30; // 깊이에 따라 Y 위치 조정
                const alpha = (z + 1) / 2; // 투명도
                const size = 120 * scale; // 이미지 크기

                ctx.globalAlpha = alpha;
                ctx.drawImage(planet.image, x - size / 2, y - size / 2, size, size);

                // 가장 앞에 있는 행성 찾기
                if (!frontPlanet || z > frontPlanet.z) {
                    frontPlanet = planet;
                }
            });

            ctx.globalAlpha = 1;

            // 선택된 행성 정보 업데이트
            if (frontPlanet) {
                planetNameEl.textContent = frontPlanet.name;
                planetNameEl.style.opacity = 1;
                warpButton.onclick = () => { window.location.href = frontPlanet.link; };
            } else {
                planetNameEl.style.opacity = 0;
            }

            requestAnimationFrame(draw);
        }

        // 마우스 드래그 이벤트
        canvas.addEventListener('mousedown', (e) => {
            dragStartX = e.clientX;
            startAngle = targetAngle;
        });
        canvas.addEventListener('mousemove', (e) => {
            if (dragStartX !== null) {
                const dx = e.clientX - dragStartX;
                targetAngle = startAngle - (dx / 200);
            }
        });
        canvas.addEventListener('mouseup', () => {
            dragStartX = null;
        });
        canvas.addEventListener('mouseleave', () => {
            dragStartX = null;
        });

        // 초기화 및 실행
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        draw();
    </script>
</body>
</html>
